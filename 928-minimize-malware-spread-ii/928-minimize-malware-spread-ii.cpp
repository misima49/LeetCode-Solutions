class Solution {
    int findParent(int i, vector<int>& parent) {
        if(parent[i] < 0) return i;
        return parent[i] = findParent(parent[i], parent);
    }
    
    void makeUnion(int u, int v, vector<int>& parent) {
        int i = findParent(u, parent);
        int j = findParent(v, parent);
        
        if(i != j) {
            if(j < i) swap(i, j);
            parent[j] += parent[i];
            parent[i] = j;
        }
    }
    
    void countInitInParent(unordered_map<int, unordered_set<int>>& parInitCount, vector<vector<int>>& graph,
                           unordered_set<int>& init, vector<int>& parent) {
        int n = graph.size();
        for(int itr : init) {
            for(int i = 0; i < n; i++) { 
                if(graph[itr][i] && init.count(i) == 0) {
                    int tempPar = findParent(i, parent);
                    parInitCount[tempPar].insert(itr);
                }
            }
        }
    }
    
    
//     void printM(unordered_map<int, unordered_set<int>> p) {
//         for(auto itr : p) {
//             cout << "\n" << itr.first << " : ";
//             for(auto it : itr.second) cout << it << " ";
//         }
//     }
    
//     void printV(vector<int>& p) {
//         for(int i : p) cout << i << " ";
//     }
    
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        unordered_set<int> init(initial.begin(), initial.end());
        vector<int> parent(n, -1);
        
        for(int i = 0; i < n; i++) {
            if(init.count(i)) continue;
            
            for(int j = 0; j < n; j++) {
                if(init.count(j) || graph[i][j] == 0 || i == j) continue;
                makeUnion(i, j, parent);
            }
        }
        
        unordered_map<int, unordered_set<int>> parInitCount;
        countInitInParent(parInitCount, graph, init, parent);
        
        // printV(parent);
        // printM(parInitCount);
        
        unordered_map<int, int> countUninfec;
        int maxSave = -1;
        int ans = 1e8;
        for(auto itr : parInitCount) {
            if(itr.second.size() == 1) {
                countUninfec[*itr.second.begin()] += (-parent[itr.first]);
                if(maxSave < countUninfec[*itr.second.begin()]) {
                    maxSave = countUninfec[*itr.second.begin()];
                    ans = *(itr.second.begin());
                } else if(maxSave == countUninfec[*itr.second.begin()]) {
                    ans = min(ans, *(itr.second.begin()));
                }
            }
        }
        
        if(ans == 1e8) return *min_element(initial.begin(), initial.end());
        return ans;
    }
 
};