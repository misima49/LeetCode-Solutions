class Solution {
    int findParent(int i, vector<int>& parent) {
        if(parent[i] < 0) return i;
        return parent[i] = findParent(parent[i], parent);
    }
    
    void makeUnion(int u, int v, vector<int>& parent) {
        int i = findParent(u, parent);
        int j = findParent(v, parent);
        
        if(i != j) {
            if(j < i) swap(i, j);
            parent[j] += parent[i];
            parent[i] = j;
        }
    }
    
    void countInitInParent(unordered_map<int, unordered_set<int>>& parInitCount, vector<vector<int>>& graph,
                           unordered_set<int>& init, vector<int>& parent) {
        int n = graph.size();
        for(int itr : init) {
            for(int i = 0; i < n; i++) { 
                if(graph[itr][i] && init.count(i) == 0) {
                    int tempPar = findParent(i, parent);
                    parInitCount[tempPar].insert(itr);
                }
            }
        }
    }
    

public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        unordered_set<int> init(initial.begin(), initial.end());
        vector<int> parent(n, -1);
        
		// First fill the parent vector
		
        for(int i = 0; i < n; i++) {
            if(init.count(i)) continue;
            
            for(int j = 0; j < n; j++) {
                if(init.count(j) || graph[i][j] == 0 || i == j) continue;
                makeUnion(i, j, parent);
            }
        }
        
		//  Make a hash of all parent nodes and the infected that it is initially connected to
		
        unordered_map<int, unordered_set<int>> parInitCount;
        countInitInParent(parInitCount, graph, init, parent);

		/* 
			Find all parent nodes that are connected to only one infected node.
			Increment that infected node's count by size of the component.
			Check if it is has the largest count and if it does then update the ans.
			Also make sure to check when the count is equal to max, in that case use 
			infected's value to determine the result.
		*/

        unordered_map<int, int> countUninfec;
        int maxSave = -1;
        int ans = 1e8;
        for(auto itr : parInitCount) {
            if(itr.second.size() == 1) {
                countUninfec[*itr.second.begin()] += (-parent[itr.first]);
                if(maxSave < countUninfec[*itr.second.begin()]) {
                    maxSave = countUninfec[*itr.second.begin()];
                    ans = *(itr.second.begin());
                } else if(maxSave == countUninfec[*itr.second.begin()]) {
                    ans = min(ans, *(itr.second.begin()));
                }
            }
        }
        
		/*
			If the ans was never updated, it means that there was no component that 
			was connected to only one infected node.
		*/
		
        if(ans == 1e8) return *min_element(initial.begin(), initial.end());
        return ans;
    }
 
};